				MicroServices
.....................................................................................
How to build distributed apps?

1.Monolithic
    Old way of building ,testing,deploying apps
2.Microservices

What is MicroService?
	Microservices - also known as the microservice architecture - is an architectural style that structures an application as a collection of services that are

Highly maintainable and testable
Loosely coupled
Independently deployable
Organized around business capabilities
Owned by a small team

The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.

Microservices are based on Design patterns:

1.Service Design pattern
2.Data Management Pattern
3.Deployment Pattern
4.Cross Cutting Patterns
5.Communication style patterns
6.Reliablity Pattern
7.Security Pattern
8.Observablity Pattern
.....................................................................................
.....................................................................................				Micro service Implemenation
...................................................................................

Micro services can be implemeneted in any language or any framework.
The frameworks provide implmentation of microservice design patterns.

Java :

1.Spring Cloud
2.Vertx
3.Quarkus

Javascript (Node.js):
1.Moleculer
2.Loopback
3.Nest
...................................................................................
				Moleculer
.................................................................................


What is Moleculer?
  Moleculer is open source Micro service framework for Node.js

Features of Moleculer:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
plugin/middleware system
7.support versioned services
8.support Streams
9.service mixins
10.built-in caching solution (Memory, MemoryLRU, Redis)
11.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
12.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
13.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
14.pluggable parameter validator
15.multiple services on a node/server
16.master-less architecture, all nodes are equal
17.parameter validation with fastest-validator
18.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
19.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
20.official API gateway, Database access and many other modules…

core concepts:

1.Service
 A service is a simple JavaScript module containing some part of a complex application. 

 A service represents a biz logic in your application.

2.Service Broker : == Spring Container

 Service Broker is the heart of Moleculer.

It is responsible for management and communication between services (local and remote). 

3.node :
 A node is a simple OS process running on a local or external network.
 A single instance of a node can host one or many services.
 node js platform - v8+libvu..

Each node must have an instance of Service Broker.

"Service Broker is one single Node instance - Node runtime"

4.Transporter
	Transporter is a communication bus that services use to exchange messages. 
 It transfers events, requests and responses.

5.Gateway
     API Gateway exposes Moleculer services to end-users.
 The gateway is a regular Moleculer service running a (HTTP, WebSockets, etc.) server. It handles the incoming requests, maps them into service calls, and then returns appropriate responses.
.....................................................................................
....................................................................................
				Project Setup
....................................................................................

1.normal node project 
2.using moleculer cli

Project creation:
.................
>mkdir microserviceapp

>cd microserviceapp

>npm init --yes

{
  "name": "microserviceapp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}

>mkdir services
>npm install moleculer --save


How to create service broker,declare service and start?


/**
 * Get the Service Broker object 
 * Declare Service
 * Start Service/deploy the service on Moleculer runtime-service Broker
 */
const { ServiceBroker } = require('moleculer')
//create instance of service broker
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,MicroService'
        }
    }
})
//deploy the service/start service broker
function main() {
    //start the service broker , start method returns promise
    broker.start()
        .then(() => console.log('broker is ready'))
        .catch(err => console.log('broker failed to start'))
}
main()

node services/helloworld.service.js
node services/helloworld.service.js
[2022-11-09T10:17:39.429Z] INFO  laptop-r2tggfdl-7732/BROKER: Moleculer v0.14.25 is starting...
[2022-11-09T10:17:39.431Z] INFO  laptop-r2tggfdl-7732/BROKER: Namespace: <not defined>
[2022-11-09T10:17:39.431Z] INFO  laptop-r2tggfdl-7732/BROKER: Node ID: laptop-r2tggfdl-7732
[2022-11-09T10:17:39.432Z] INFO  laptop-r2tggfdl-7732/REGISTRY: Strategy: RoundRobinStrategy
[2022-11-09T10:17:39.434Z] INFO  laptop-r2tggfdl-7732/REGISTRY: Discoverer: LocalDiscoverer
[2022-11-09T10:17:39.440Z] INFO  laptop-r2tggfdl-7732/BROKER: Serializer: JSONSerializer
[2022-11-09T10:17:39.450Z] INFO  laptop-r2tggfdl-7732/BROKER: Validator: FastestValidator
[2022-11-09T10:17:39.452Z] INFO  laptop-r2tggfdl-7732/BROKER: Registered 13 middleware(s).
[2022-11-09T10:17:39.468Z] INFO  laptop-r2tggfdl-7732/REGISTRY: '$node' service is registered.
[2022-11-09T10:17:39.469Z] INFO  laptop-r2tggfdl-7732/REGISTRY: 'hello' service is registered.
[2022-11-09T10:17:39.470Z] INFO  laptop-r2tggfdl-7732/$NODE: Service '$node' started.
[2022-11-09T10:17:39.470Z] INFO  laptop-r2tggfdl-7732/HELLO: Service 'hello' started.
[2022-11-09T10:17:39.471Z] INFO  laptop-r2tggfdl-7732/BROKER: ✔ ServiceBroker with 2 service(s) started successfully in 8ms.
broker is ready
[2022-11-09T10:17:39.574Z] INFO  laptop-r2tggfdl-7732/$NODE: Service '$node' stopped.
[2022-11-09T10:17:39.575Z] INFO  laptop-r2tggfdl-7732/HELLO: Service 'hello' stopped.
[2022-11-09T10:17:39.577Z] INFO  laptop-r2tggfdl-7732/BROKER: ServiceBroker is stopped. Good bye.
.....................................................................................

How to invoke/call Service methods?

There are many ways

1.By using broker.start method
2.By using  REPL cli
3.By using another service => Service to Service calls

/**
 * Get the Service Broker object 
 * Declare Service
 * Start Service/deploy the service on Moleculer runtime-service Broker
 */
const { ServiceBroker } = require('moleculer')
//create instance of service broker
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,MicroService'
        }
    }
})
//deploy the service/start service broker
function main() {
    //start the service broker , start method returns promise
    broker.start()
        .then(() => {
            console.log('broker is ready')
            //service calls 
            broker.call('hello.sayHello').then(res => {
                console.log(res)
            }).catch(err => {
                console.log('service call failed', err)
            })
        })
        .catch(err => console.log('broker failed to start'))
}
main()

How to optimize the main code using async...await?
/**
 * Get the Service Broker object 
 * Declare Service
 * Start Service/deploy the service on Moleculer runtime-service Broker
 */
const { ServiceBroker } = require('moleculer')
//create instance of service broker
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,MicroService'
        }
    }
})
//deploy the service/start service broker
function main_() {
    //start the service broker , start method returns promise
    broker.start()
        .then(() => {
            console.log('broker is ready')
            //service calls 
            broker.call('hello.sayHello').then(res => {
                console.log(res)
            }).catch(err => {
                console.log('service call failed', err)
            })
        })
        .catch(err => console.log('broker failed to start'))
}
async function main() {
    try {
        await broker.start()
        const res = await broker.call('hello.sayHello')
        console.log(res)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
Multi services on a single broker and multi methods on single service

const { ServiceBroker } = require('moleculer')
//create instance of service broker
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,MicroService'
        }
    }
})
broker.createService({
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai,MicroService'
        }
    }
})
async function main() {
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello')
        console.log(hello)
        const hai = await broker.call('hai.sayHai')
        console.log(hai)
    }
    catch (err) {
        console.log(err)
    }
}
main()

Multi methods:
.............
const { ServiceBroker } = require('moleculer')
//create instance of service broker
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello,MicroService'
        },
        sayHai(){
            return 'Hai,Micro Service'
        },
        sayGreet(){
            return 'Greet,Mico Service'
        }
    }
})

async function main() {
    try {
        await broker.start()
        const hello = await broker.call('greeter.sayHello')
        console.log(hello)
        const hai = await broker.call('greeter.sayHai')
        console.log(hai)
        const greet = await broker.call('greeter.sayGreet')
        console.log(greet)

    
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			    Service api parameters
....................................................................................

How to pass params to Service methods? How to read args from the service Method?

Parameters are stored inside special object called "Context"

Context Object:

1.Similar to Broker Object
2.It has all capacity of Broker object
3.Context object is used inside service definitions , where ever you require broker
  Object reference.

context object already created, and its refernce is avaiable inside "Service method" as args.

reading parameters

1.context.params 
  params are literal object what ever parameter we pass, it will inside this

context.params.variable

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'hello',
    actions: {
        //args
        sayHello(ctx) {
            console.log(ctx)
            const { message } = ctx.params
            //return `${ctx.params.message},MicroService`
            return `${message},MicroService`
        }
    }
})

async function main() {
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello', { message: 'Hello' })
        console.log(hello)

    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
				   actions
....................................................................................
				 actions Syntax:

1.normal pattern

   actions: {
        multiply(ctx) {
            const a = ctx.params.a
            const b = ctx.params.b
            return a * b
        }
    }

2.expanded Pattern
    -This pattern is very usefull for having additional information for a methods.
     or meta information.

 params validation,cache,fallback---extra  information

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'hello',
    actions: {
        //args
        // sayHello(ctx) {
        //     console.log(ctx)
        //     const { message } = ctx.params
        //     //return `${ctx.params.message},MicroService`
        //     return `${message},MicroService`
        // }
        //expanded syntax
        sayHello: {
            //logic of the method will go inside handler
            handler(ctx) {
               const { message } = ctx.params
               return `${message} MicroService`
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello', { message: 'Hello' })
        console.log(hello)

    }
    catch (err) {
        console.log(err)
    }
}
main()

Actions Meta Data:
..................
Params Validation
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'math',
    actions: {
        add: {
            //meta information: validation information
            params: {
                a: { type: 'number' },
                b: { type: 'number' }
            },
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
         const result = await broker.call('math.add', { a: 10, b: 20 })
        // const result = await broker.call('math.add', { a: "10", b: 20 })

        console.log(result)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
....................................................................................
		    Dynamic Parameters and dynamic invocation of services
...................................................................................

Moleculer has a tool called "Moleculer REPL"
>npm install moleculer-repl --save-dev



const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        divide: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a / b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()
   
    } catch (err) {
        console.log(err)
    }
}
main()

mol $ call math.divide --a 10000 --b 234
>> Call 'math.divide' with params: { a: 10000, b: 234 } with meta: { '$repl': true } with options: {}
>> Execution time:4ms
>> Response:
42.73504273504273
	     .....................................................................................
			     Service Communication
.....................................................................................

Service Representation

1.rpc 
2.rest
3.graphql

Service communications

1.rpc to rpc

2.rest to rest

2.rest to rpc


Moleculer is microservice, generally microservices may be distributed across multiple machines(nodes) , which communicates via networks.


1.Service communication with in single broker - local service

2.Service communication across multiple service brokers - remote service communication

Communication style

1. can be sync
2. can be async

RPI style
   method to method call
Event driven style
   methods communicates via events.



Types of services:

1.local service
   service which is implemented on single broker.
2.remote service
   Service which is implemented across the brokers.
 
Services can communicate within service broker-single node arch
Services can communicate across service brokers - multi node arch

How services are interacting each other?

 Using "Context" Object

Actors:

 1.Caller service, who is calling /consuming other services

 2.Callee service, who is called by others

....................................................................................

Use case: RPC TO RPC , within single Broker(Single Node)
........................................................
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('adder.add', { a: a, b: b })
            }
        }
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a + b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

How to test?
node services/math.service.js

mol $ call math.add --a 10 --b 20
.....................................................................................
			 Moleculer Repl Admin commands
...................................................................................

$nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤═════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼─────╢
║ laptop-r2tggfdl-72136 (*) │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ ?   ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧═════╝
It list how many nodes are running.

..
mol $ services
╔═════════╤═════════╤══════════╤═════════╤════════╤═══════╗
║ Service │ Version │    State │ Actions │ Events │ Nodes ║
╟─────────┼─────────┼──────────┼─────────┼────────┼───────╢
║ $node   │       - │    OK    │       7 │      0 │ 1     ║
║ adder   │       - │    OK    │       1 │      0 │ 1     ║
║ math    │       - │    OK    │       1 │      0 │ 1     ║
╚═════════╧═════════╧══════════╧═════════╧════════╧═══════╝
It list all services across the brokers.

mol $ actions
╔════════════════╤═══════╤══════════╤════════╤═══════════════════════════════════════════════════════════════════════════╗
║ Action         │ Nodes │ State    │ Cached │ Params                                                                    ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ $node.actions  │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withEndpoints, onlyAvailable                     ║
║ $node.events   │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withEndpoints, onlyAvailable                     ║
║ $node.health   │ (*) 1 │    OK    │   No   │                                                                           ║
║ $node.list     │ (*) 1 │    OK    │   No   │ withServices, onlyAvailable                                               ║
║ $node.metrics  │ (*) 1 │    OK    │   No   │ types, includes, excludes                                                 ║
║ $node.options  │ (*) 1 │    OK    │   No   │                                                                           ║
║ $node.services │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withActions, withEvents, onlyAvailable, grouping ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ adder.add      │ (*) 1 │    OK    │   No   │ a, b                                                                      ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ math.add       │ (*) 1 │    OK    │   No   │ a, b                                                                      ║
╚════════════════╧═══════╧══════════╧════════╧═══════════════════════════════════════════════════════════════════════════╝
It lists all actions across the service brokers.

mol $ info

=======================
  General information
=======================

    CPU                      : Arch: x64, Cores: 12
    Memory                   : [|||||--------------] 51 GB free
    Heap                     : [-------------------] 16.8 MB
    OS                       : win32 (Windows_NT)
    IP                       : 172.21.112.1, 172.17.64.1, 192.168.1.8
    Hostname                 : LAPTOP-R2TGGFDL

    Node version             : v18.12.1
    Moleculer version        : 0.14.26
    Protocol version         : 4

    Current time             : Thu Nov 10 2022 10:20:17 GMT+0530 (India Standard Time)

======================
It list all information related to your broker,os...
.....................................................................................					Async services
....................................................................................

Service return Promise (async)

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //invoke adder service to get result
                //ctx.call('adder.add', { a: a, b: b })
                return ctx.call('adder.add', { a, b })
            }
        }
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            params: {
                //fastest-validator rules:https://github.com/icebob/fastest-validator
                a: 'number',
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                const { a, b } = ctx.params
                // return a + b //Promise.resolve(a+b)
                return new this.Promise((resolve, reject) => {
                    setTimeout(resolve, 5000, (a + b))
                })
            }
        }
    }
})
async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
 How to Pass additional Meta Data and How to access meta information
....................................................................................
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //access meta information
                return ctx.call('adder.add', { a, b }, { meta: { secrete: 'foo' } })
            }
        }
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            params: {
                //fastest-validator rules:https://github.com/icebob/fastest-validator
                a: 'number',
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                const { a, b } = ctx.params
                // return a + b //Promise.resolve(a+b)
                console.log('meta =>', ctx.meta)
                return new this.Promise((resolve, reject) => {
                    setTimeout(resolve, 5000, (a + b))
                })
            }
        }
    }
})
async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			Remote Service Communication
				(Networking)

If services(apps) are running different nodes with in same os or different os,
they cant talk directly, where is network is involved.


.............................................................................................
			 How brokers can talk each other?

Networking:
..........
in order to communicate with other nodes(servicebrokers) you need to configure a "Transporter"

Transporter:
 It is a bus which transports, calls,messages,events....

Transporter connected via a centeral Message broker that provides a reliable way of exchanging messages among remote nodes.


-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporter
TCP transporter - part of moleculer

Third party Message Brokers
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter
Custom Transporter

TCP transporter:

This is a no-dependency, zero-configuration TCP transporter.
It uses Gossip protocol to disseminate node statuses, service list and heartbeats.
It contains an integrated UDP discovery feature to detect new and disconnected nodes on the network.
If the UDP is prohibited on your network, use urls option. It is a list of remote endpoints (host/ip, port, nodeID). It can be a static list in your configuration or a file path which contains the list.


Use case :How to use TCP transport as channel for service Communications.

We need to configure Service Broker to enable transporter.

ServiceBroker object creation:

const broker = new ServiceBroker();
 Here we have not passed any parameter to ServiceBroker Constructor, if you dont, the default parameters will be passed.

Service Broker Parameters are called as "ServiceBroker Schema"

We can override service Broker Schema to enable broker vide features.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker({
    transporter:"TCP"
});

eg:
App1
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter:"TCP"
})

broker.createService({
    name: 'math',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('adder.add', { a: a, b: b })
            }
        },
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                //service to service communication via context object 
                return ctx.call('multiplier.multiply', { a: a, b: b })
            }
        },
    }
})

broker.createService({
    name: 'adder',
    actions: {
        add: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a + b
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

App2
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'multiplier',
    actions: {
        multiply: {
            //param validation logic
            params: {
                a: "number",
                b: "number"
            },
            //biz logic 
            handler(ctx) {
                const a = ctx.params.a
                const b = ctx.params.b
                return a * b
            }
        }
    }
})



async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

Testing

Node1
node services/math.service.js
[2022-11-10T05:20:16.175Z] INFO  laptop-r2tggfdl-82848/BROKER: Moleculer v0.14.26 is starting...
[2022-11-10T05:20:16.177Z] INFO  laptop-r2tggfdl-82848/BROKER: Namespace: <not defined>
[2022-11-10T05:20:16.177Z] INFO  laptop-r2tggfdl-82848/BROKER: Node ID: laptop-r2tggfdl-82848
[2022-11-10T05:20:16.179Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Strategy: RoundRobinStrategy
[2022-11-10T05:20:16.179Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Discoverer: LocalDiscoverer
[2022-11-10T05:20:16.186Z] INFO  laptop-r2tggfdl-82848/BROKER: Serializer: JSONSerializer
[2022-11-10T05:20:16.198Z] INFO  laptop-r2tggfdl-82848/BROKER: Validator: FastestValidator
[2022-11-10T05:20:16.200Z] INFO  laptop-r2tggfdl-82848/BROKER: Registered 13 middleware(s).
[2022-11-10T05:20:16.202Z] INFO  laptop-r2tggfdl-82848/BROKER: Transporter: TcpTransporter
[2022-11-10T05:20:16.215Z] INFO  laptop-r2tggfdl-82848/TRANSIT: Connecting to the transporter...
[2022-11-10T05:20:16.218Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: TCP server is listening on port 51606
[2022-11-10T05:20:16.229Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 172.21.112.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.230Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 172.17.64.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.231Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 192.168.1.8:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.232Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP Multicast Server is listening on 127.0.0.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:16.233Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: UDP discovery started.
[2022-11-10T05:20:16.233Z] INFO  laptop-r2tggfdl-82848/TRANSPORTER: TCP Transporter started.
[2022-11-10T05:20:16.739Z] INFO  laptop-r2tggfdl-82848/REGISTRY: '$node' service is registered.
[2022-11-10T05:20:16.741Z] INFO  laptop-r2tggfdl-82848/REGISTRY: 'math' service is registered.
[2022-11-10T05:20:16.743Z] INFO  laptop-r2tggfdl-82848/REGISTRY: 'adder' service is registered.
[2022-11-10T05:20:16.743Z] INFO  laptop-r2tggfdl-82848/$NODE: Service '$node' started.
[2022-11-10T05:20:16.744Z] INFO  laptop-r2tggfdl-82848/MATH: Service 'math' started.
[2022-11-10T05:20:16.745Z] INFO  laptop-r2tggfdl-82848/ADDER: Service 'adder' started.
[2022-11-10T05:20:16.745Z] INFO  laptop-r2tggfdl-82848/BROKER: ✔ ServiceBroker with 3 service(s) started successfully in 530ms.
mol $ [2022-11-10T05:20:52.460Z] INFO  laptop-r2tggfdl-82848/REGISTRY: Node 'laptop-r2tggfdl-53460' reconnected.
mol $ nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤════════════════════════════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU                        ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼────────────────────────────╢
║ laptop-r2tggfdl-53460     │ 2        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■■.................] 14% ║
║ laptop-r2tggfdl-82848 (*) │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■...................] 4%  ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧════════════════════════════╝
..............................

Node 2:
node services/multiplier.service.js
[2022-11-10T05:20:49.701Z] INFO  laptop-r2tggfdl-53460/BROKER: Moleculer v0.14.26 is starting...
[2022-11-10T05:20:49.702Z] INFO  laptop-r2tggfdl-53460/BROKER: Namespace: <not defined>
[2022-11-10T05:20:49.703Z] INFO  laptop-r2tggfdl-53460/BROKER: Node ID: laptop-r2tggfdl-53460
[2022-11-10T05:20:49.704Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Strategy: RoundRobinStrategy
[2022-11-10T05:20:49.705Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Discoverer: LocalDiscoverer
[2022-11-10T05:20:49.711Z] INFO  laptop-r2tggfdl-53460/BROKER: Serializer: JSONSerializer
[2022-11-10T05:20:49.721Z] INFO  laptop-r2tggfdl-53460/BROKER: Validator: FastestValidator
[2022-11-10T05:20:49.723Z] INFO  laptop-r2tggfdl-53460/BROKER: Registered 13 middleware(s).
[2022-11-10T05:20:49.725Z] INFO  laptop-r2tggfdl-53460/BROKER: Transporter: TcpTransporter
[2022-11-10T05:20:49.736Z] INFO  laptop-r2tggfdl-53460/TRANSIT: Connecting to the transporter...
[2022-11-10T05:20:49.739Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: TCP server is listening on port 51607
[2022-11-10T05:20:49.756Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 172.21.112.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.757Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 172.17.64.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.760Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 192.168.1.8:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.761Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP Multicast Server is listening on 127.0.0.1:4445. Membership: 239.0.0.0
[2022-11-10T05:20:49.764Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: UDP discovery started.
[2022-11-10T05:20:49.766Z] INFO  laptop-r2tggfdl-53460/TRANSPORTER: TCP Transporter started.
[2022-11-10T05:20:50.289Z] INFO  laptop-r2tggfdl-53460/REGISTRY: '$node' service is registered.
[2022-11-10T05:20:50.290Z] INFO  laptop-r2tggfdl-53460/REGISTRY: 'multiplier' service is registered.
[2022-11-10T05:20:50.293Z] INFO  laptop-r2tggfdl-53460/$NODE: Service '$node' started.
[2022-11-10T05:20:50.299Z] INFO  laptop-r2tggfdl-53460/MULTIPLIER: Service 'multiplier' started.
[2022-11-10T05:20:50.301Z] INFO  laptop-r2tggfdl-53460/BROKER: ✔ ServiceBroker with 2 service(s) started successfully in 564ms.
mol $ [2022-11-10T05:20:53.977Z] INFO  laptop-r2tggfdl-53460/REGISTRY: Node 'laptop-r2tggfdl-82848' reconnected.

mol $ nodes
╔═══════════════════════════╤══════════╤═════════╤════════╤════════════════════╤══════════╤════════════════════════════╗
║ Node ID                   │ Services │ Version │ Client │ IP                 │    State │ CPU                        ║
╟───────────────────────────┼──────────┼─────────┼────────┼────────────────────┼──────────┼────────────────────────────╢
║ laptop-r2tggfdl-53460 (*) │ 2        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■■.................] 15% ║
║ laptop-r2tggfdl-82848     │ 3        │ 0.14.26 │ nodejs │ 172.21.112.1  (+2) │  ONLINE  │ [■■..................] 11% ║
╚═══════════════════════════╧══════════╧═════════╧════════╧════════════════════╧══════════╧════════════════════════════╝

mol $
.............................................................................................
			  How to use other Message Brokers
.....................................................................................

Steps:
1.You need a message broker software -  redis,nats,rabbitmq...

docker run  --name nats-main -p 4222:4222 -p 6222:6222 -p 8222:8222 nats

2.you need to install driver for connecting third message broker.
 
incase of nat
 npm install nats --save

3.configure in the service broker

const broker = new ServiceBroker({
    transporter:"nats://localhost:4222"
})
....................................................................................
			Serialization and Deserialization
.....................................................................................

Apps deal different type of data like strings,numbers,objects,arrays when we transport these data via 'network' we wont transfer as it is rather we convert 
that into another format  , this conversion is called as "serialization".

Moleculer takes care of serialization by default.
The data is seralized into "JSON" By default

The receiver app will deserialze the data into javascript format.

You dont need to tell the serializer , because there is default seralizer

Types of serialzer:

1.JSON
2.Avro
3.MsgPack
4.NotePack
5.ProtoBuf
6.Thrift
7.CBOR
etc...

How to use MsgPack?

npm install msgpack5 --save

const broker = new ServiceBroker({
    //transporter 
    // transporter: "TCP"
    transporter: "nats://localhost:4222",
    serializer:"MsgPack"
})
.....................................................................................
			  Methods calls and Caching
...................................................................................

if you call method over network, the method gets called every time...this is expensive.
if method is called with same set of parameters, the result would be the same , then why should we call again and again

in order to optimize we have concept called "caching"

Caching types:
1.in memory cache 
   The data is cached in the main memory itself.
  Pros:
   You dont need any extra softwares to maintain caching.
   It is super fast
  Cons:
    if server restarts, the cached data will be lost....
    if you want persist cached data even after the server restarts, 
   you can use third party caching solutions like "redis,Memcached"

Moleculer and Caching:
 You can configure caching in moleculer.

what type of caching provider you use?

const broker = new ServiceBroker({
    //transporter 
    // transporter: "TCP"
    transporter: "nats://localhost:4222",
    serializer:"MsgPack",
    cacher:"Memory" // enables in memory cache- RAM
})

In the Actions we can configure caching...

actions:{
  add:{
    params:{},
    cache:true,
    handler(){ }
  }
}

In Memory Caching Enabling:
...........................

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222",
    serializer: "MsgPack",
    cacher: "Memory" // enables in memory cache- RAM
})
What if i want third party caching?



Redis is the most popular implement for caching....
Steps:

Run redis server
docker run --name my-redis -p 6379:6379 -d redis

Run redis-client called redis-cli

docker exec -it my-redis sh
# redis-cli
127.0.0.1:6379> keys *
(empty array)


2.install redis driver
npm install ioredis -save

3.const { ServiceBroker } = require('moleculer')

//passing service broker schema : the configuration
//if you dont supply, the service broker will have its own default values
const broker = new ServiceBroker({
    //transporter 
    // transporter: "TCP"
    transporter: "nats://localhost:4222",
    serializer: "MsgPack",
    //cacher: "Memory" // enables in memory cache- RAM
    cacher:"Redis" // redis://localhost:6379
})

//math service 
broker.createService({
    name: 'math',
    actions: {
        add: {
            cache: true,
            handler(ctx) {
                const { a, b } = ctx.params
                console.log('Math.calculate is called')
                //call remote service
                return ctx.call("add.calculate", { a, b })
            }
        }
    }
})



async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()

const { ServiceBroker } = require('moleculer')


//passing service broker schema : the configuration
//if you dont supply, the service broker will have its own default values
const broker = new ServiceBroker({
    //transporter 
    // transporter: "TCP"
    transporter: "nats://localhost:4222",
    serializer: "MsgPack",
    //cacher: "Memory"
    cacher:"Redis" // redis://localhost:6379

})

//math service 
broker.createService({
    name: 'add',
    actions: {
        calculate: {
            cache: true,
            handler(ctx) {
                const { a, b } = ctx.params
                //call remote service
                console.log('Add.calculate is called')
                return `${ctx.nodeID} => ${a + b}`
            }
        }
    }
})



async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
......................................................................................			   Method types:Private Methods
.....................................................................................
Service Methods:

1.public methods
    methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.


public methods:
 any thing if you write inside actions are called public methods.

actions: { 
   
  //public methods
  sayHello:{
     handler(ctx){

      }
  }

}

private methods:

createService({

 //public methods
 actions: {

 },

 //private methods
 methods: {


 }

})


const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'math',
    //public methods
    actions: {
        //args
        add: {
            handler(ctx) {
                return this.addNos(ctx.params.a, ctx.params.b)
            }
        }
    },
    methods: {
        addNos(a, b) {
            return a + b
        }
    }
})

async function main() {
    try {
        await broker.start()
        const res = await broker.call('math.add', { a: 1, b: 2 })
        console.log(res)

    }
    catch (err) {
        console.log(err)
    }
}
main()

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //call private methods
                return this.addNums(a,b)
            }
        }
    },
    methods: {
        addNums(a = 0, b = 0) {
            return a + b
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
......................................................................................			   Method types:life cycle methods
.....................................................................................

There are life cycles methods for broker and also for services

life cycles are called various stages of server and broker life

Broker Life Cycle Methods

Service life cycle methods


const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({

    // Called after broker created.
    async created(broker) {
        console.log('Broker is created')
    },

    // Called after broker started.
    async started(broker) {
        console.log('Broker is started')
    },
    // Called after broker stopped.
    async stopped(broker) {
        console.log('Broker is stopped')

    }
})

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //call private methods
                return this.addNums(a, b)
            }
        }
    },
    methods: {
        addNums(a = 0, b = 0) {
            return a + b
        }
    },
    //life cycles 
    created() {
        console.log('Service is created')
    },
    merged() {
        console.log('Service is merged')
    },
    async started() {
        console.log('Service is started')
    },
    async stopped() {
        console.log('Service is stopped')
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
...................................................................................
			 Service relationship
...................................................................................
Services may have relationship with other services.
1.has a relationship - dependency
2.is a relationship - inheritance

Service dependency:
 if your service depends on other services, use the dependencies properties in the scema, the service waits for dependent services before calls the start life cycle event handler.
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker();

broker.createService({
    name: 'comments',
    actions: {
        findAll() {
            return 'Comments'
        }
    },
    //Dependency
    dependencies: [
        "posts"
    ],
    //Life cycle methods
    created() {
        console.log('Comments Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Comments Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Comments Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Comments Service stoped')
    },

})

broker.createService({
    name: 'posts',
    actions: {
        findAll() {
            return [{ id: 1, name: 'Microservices' }]
        }
    },
    //Life cycle methods
    created() {
        console.log('Posts Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Posts Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Posts Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Posts Service stoped')
    }
})


async function main() {

    try {
        await broker.start()
        await broker.repl()

    } catch (error) {
        console.log(error)
    }
}
main();
.....................................................................................
			....................................................................................
			 Service Code Reuse- Service Inheritance
....................................................................................

A Service has many options, those options may be repeated in many other services,
like common settings.

We can isloate common features / options into a separate service, we can reuse across multiple services -  Inheritance.

How to implement inheritance in moleculer?

Javascript can support only single inheritance, only one parent allowed for a child.

Java like languages support interfaces for multi parent patterns, javascript has no such facility.

Javascript has a design pattern and implementation ,called "mixin", through mixin we can inherit many super objects.

Moleculer has mixin property

Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.
etc...

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//parent Services
const hello = {
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,From Parent';
        }
    }
}
const hai = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai, From Parent'
        }
    }
}
//Child Service
broker.createService({
    name: 'greeter',
    mixins: [hello, hai]
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

mol $ call greeter.sayHai
>> Call 'greeter.sayHai' with params: {} with meta: { '$repl': true }
>> Execution time:4ms
>> Response:
'Hai, From Parent'
mol $ call greeter.sayHello
>> Call 'greeter.sayHello' with params: {} with meta: { '$repl': true }
>> Execution time:1ms
>> Response:
'Hello,From Parent'
.....................................................................................
		Defining Service Properties and How to override them

Service has 

1.methods called actions
2.properties which are defined inside "settings"
3.parent settings and actions can be overriden inside child service.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//parent Services
const hello = {
    name: 'hello',
    settings: {
        message1: 'Hello Parent service'
    },
    actions: {
        sayHello() {
            return 'Hello,From Parent';
        }
    }
}
const hai = {
    name: 'hai',
    settings: {
        message2: 'Hai Parent service'
    },
    actions: {
        sayHai() {
            return 'Hai, From Parent'
        }
    }
}

broker.createService({
    name: 'greeter',
    mixins: [hello, hai], //inheritance
    settings: {
        message2: 'Hai Parent and Child service'
    },
    actions: {
        sayGreet() {
            return 'Child method'
        },
        getProp() {
            return `${this.settings.message1} ${this.settings.message2}`
        }
    }
})
async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
.....................................................................................
			Internal Settings
.....................................................................................
There are some settings which are internal.
Internal Settings are identified by "$SettingName"
$noVersionPrefix
etc...
.....................................................................................
...................................................................................
				Types of Services

Moleculer Provides two types of service

1.Custom Services
   The services are created with broker object
2.Built services
  The services are provided by Broker
 $node
   Used for administration
...................................................................................
				Types of Services

Moleculer Provides two types of service

1.Custom Services
   The services are created with broker object
2.Built services
  The services are provided by Broker
 $node
   Used for administration


How to list all services using $node

 call $node.services
>> Call '$node.services' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    name: '$node',
    version: undefined,
    fullName: '$node',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  },
  {
    name: 'greeter',
    version: undefined,
    fullName: 'greeter',
    settings: { port: 3000, host: 'ibm.com' },
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  }
]

$ call $node.list
>> Call '$node.list' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    id: 'laptop-r2tggfdl-17828',
    instanceID: 'c7fd8078-2bf2-42ee-88f6-1fd20184eb3c',
    available: true,
    local: true,
    lastHeartbeatTime: 0,
    config: {},
    client: { type: 'nodejs', version: '0.14.21', langVersion: 'v16.15.0' },
    metadata: {},
    ipList: [ '172.26.240.1', '172.22.176.1', '192.168.0.105' ],
    port: null,
    hostname: 'LAPTOP-R2TGGFDL',
    udpAddress: null,
    cpu: null,
    cpuSeq: null,
    seq: 3,
    offlineSince: null
  }
]

broker.createService({})
..................................................................................
			    Services types
1.sync service
2.async service
.....
async services: Promise

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'greeter',
    actions: {
        //args
        async sayHello(ctx) {
            const response = await ctx.call('hello.sayHello')
            //console.log(response)
            //    response.then(res=>console.log(res))
            return response
        }
    }
})
broker.createService({
    name: 'hello',
    actions: {
        //args
        sayHello(ctx) {
            return new this.Promise((resolve, reject) => {
                setTimeout(resolve, 5000, 'Hello,Async')
            })
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			  Service Versioning
.....................................................................................
Each service can have version no, based on version no services can be indentified
so that the same service can be duplicated with various features.

{ 
 name:'posts'
 version:1
}
how to invoke service
v1.posts.findAll
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//declare service
broker.createService({
    name: 'posts',
    version: 1,
    actions: {
        //args
        async findAll(ctx) {
            return 'posts -v1'
        }
    }
})
broker.createService({
    name: 'posts',
    version: 2,
    actions: {
        //args
        async findAll(ctx) {
            return 'posts -v2'
        }
    }
})
async function main() {
    try {
        await broker.start()
        broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main().
.....................................................................................					.....................................................................................
			  Event Driven Architecture
.....................................................................................

Service communication can happen

Communication style

Remote Procedure Invocation - method to method calls (sync or async)

Messaging
  Services talk without calling methods, but they communicate by passing messages 
via message brokers

events can be sent within single broker
events can be distributed across the broker-Distributed event driven arch.


Broker has a built-in event bus to support Event-driven architecture and to send events to local and remote services.
....................................................................................

Callee: Events Listeners

   events: {
        "order.created": {
            handler(ctx) {
                console.log("Payload:", ctx.params);
                console.log("Sender:", ctx.nodeID);
                console.log("Metadata:", ctx.meta);
                console.log("The called event name:", ctx.eventName);
            }
        }
    }

caller: Event emission

 broker/ctx.emit("order.created",{order:{id:1,name:'test'}}) - one to one
 broker/ctx.broadcast("order.created",{order:{id:1,name:'test'}}) - one to many


eg:
app1
cart.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'cart',
    actions: {
        checkout: {
            //biz logic 
            handler(ctx) {
                const { id, name, qty } = ctx.params
                //service to service communication via context object 
                ctx.emit('order.created', { id: id, name: name, qty: qty })
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

app2
order.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'order',
    events: {
        "order.created": {
            handler(ctx) {
                //here you can persist data into database
                const data = ctx.params
                console.log(data)
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

open two cmd

1.for app1
ol $ call cart.checkout --id 1 --name tv --qty 1
>> Call 'cart.checkout' with params: { id: 1, name: 'tv', qty: 1 } with meta: { '$repl': true }
>> Execution time:1ms
>> Response:
undefined
mol $

2.for app2
mol $ { id: 1, name: 'tv', qty: 1 }
mol $

....................********************.............................................
.....................................................................................
			  Event Driven Architecture
.....................................................................................

Service communication can happen

Communication style

Remote Procedure Invocation - method to method calls (sync or async)

Messaging
  Services talk without calling methods, but they communicate by passing messages 
via message brokers

events can be sent within single broker
events can be distributed across the broker-Distributed event driven arch.


Broker has a built-in event bus to support Event-driven architecture and to send events to local and remote services.
....................................................................................

Callee: Events Listeners

   events: {
        "order.created": {
            handler(ctx) {
                console.log("Payload:", ctx.params);
                console.log("Sender:", ctx.nodeID);
                console.log("Metadata:", ctx.meta);
                console.log("The called event name:", ctx.eventName);
            }
        }
    }

caller: Event emission

 broker/ctx.emit("order.created",{order:{id:1,name:'test'}}) - one to one
 broker/ctx.broadcast("order.created",{order:{id:1,name:'test'}}) - one to many


eg:
app1
cart.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'cart',
    actions: {
        checkout: {
            //biz logic 
            handler(ctx) {
                const { id, name, qty } = ctx.params
                //service to service communication via context object 
                ctx.emit('order.created', { id: id, name: name, qty: qty })
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

app2
order.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "TCP"
})

broker.createService({
    name: 'order',
    events: {
        "order.created": {
            handler(ctx) {
                //here you can persist data into database
                const data = ctx.params
                console.log(data)
            }
        }
    }
})


async function main() {
    try {
        //start the broker 
        await broker.start()
        //use repl prompt
        broker.repl()

    } catch (err) {
        console.log(err)
    }
}
main()

open two cmd

1.for app1
ol $ call cart.checkout --id 1 --name tv --qty 1
>> Call 'cart.checkout' with params: { id: 1, name: 'tv', qty: 1 } with meta: { '$repl': true }
>> Execution time:1ms
>> Response:
undefined
mol $

2.for app2
mol $ { id: 1, name: 'tv', qty: 1 }
mol $

....................********************.............................................

			   REST API Design
..................................................................................
Moleculer Modules:
..................

Moleculer core lib provides only how to create backend services, service interactions.

If i want to integrate lets say, rest api,databases, then we have to look at moleculer modules.

1.Gateways
2.Database and stores
3.Metrics & Tracing 
4.General 
5.Security
6.Tasks&Queues
7.Jobs
etc...

1.GateWay : moleculer-web:Official API Gateway for Moleculer framework.

npm install moleculer-web --save

Features:

support HTTP & HTTPS
serve static files
multiple routes
support global, route, alias middlewares
support file uploading
alias names (with named parameters & REST shorthand)
whitelist
multiple body parsers (json, urlencoded)
CORS headers
ETags
HTTP2
Rate limiter
before & after call hooks
Buffer & Stream handling
middleware mode (use as a middleware in ExpressJS Application)
support authorization and auth


GateWay is entry point to microservices apps

How to create web server and start ?


const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

//create ApiGateWayService
broker.createService(ApiGateWay)

async function main() {
    await broker.start();
}
main();

syntax -2
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})
async function main() {
    await broker.start();
}
main();
...................................................................................
			How to access back end services via GateWay
...................................................................................
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

//Back end Service
broker.createService({
    name: 'hello',
    actions: {
        sayHello: {
            handler(ctx) {
                return 'Hello,REST Service'
            }
        }
    }
})


//Gate Way Service
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})
async function main() {
    await broker.start();
}
main();

Test URLS:

 call hello.sayHello 

   http://localhost:3000/serviceName/actionMethodName
   http://localhost:3000/hello/sayHello
If you want to access , $node services
   http://localhost:3000/~node/health

....................................................................................
			 How to return json from the service
....................................................................................
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})

//payload 
const payload = [
    { id: 1, name: 'Subramanian', status: true },
    { id: 2, name: 'Murugan', status: false },
    { id: 1, name: 'Geetha', status: true }
]

//back end service 
broker.createService({
    name: 'profile',
    actions: {
        list: {
            handler(ctx) {
                return payload
            }
        }
    }
})

async function main() {
    await broker.start();
}
main();
.....................................................................................
			  Router configuration
.....................................................................................
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    settings: {
        routes: [{
            path: '/api'
        }, {
            path: '/admin'
        }]
    }
})

//payload 
const payload = [
    { id: 1, name: 'Subramanian', status: true },
    { id: 2, name: 'Murugan', status: false },
    { id: 1, name: 'Geetha', status: true }
]

//back end service 
broker.createService({
    name: 'profile',
    actions: {
        list: {
            handler(ctx) {
                return payload
            }
        }
    }
})

async function main() {
    await broker.start();
}
main();
.....................................................................................	
			   WhiteList
...................................................................................
if you dont want to publish all actions,you can filter them with whitlist option.
Use match strings or regexp in list.
if you want to enable all actions "**"

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    settings: {
        routes: [{
            path: '/api',
            whitelist: [
                "profile.list", "profile.update","profile.save"
            ]
        }, {
            path: '/admin'
        }]
    }
})

//payload 
const payload = [
    { id: 1, name: 'Subramanian', status: true },
    { id: 2, name: 'Murugan', status: false },
    { id: 1, name: 'Geetha', status: true }
]

//back end service 
broker.createService({
    name: 'profile',
    actions: {
        list: {
            handler(ctx) {
                return payload
            }
        },
        save: {
            handler(ctx) {
                return 'save'
            }
        },
        remove: {
            handler(ctx) {
                return 'remove'
            }
        },
        update: {
            handler(ctx) {
                return 'update'
            }
        }
    }
})

async function main() {
    await broker.start();
}
main();
....................................................................................

			URL Mapping in moleculer
..................................................................................

http://localhost:3000/api/serviceName/actionName

  This is not good way to map urls , which more difficult to remember, it is not user friendly
it is not even secure,the reason, we expose the back end service to end users.

Aliases:
........
  You can use aliases(dummyname/fakename)-Virtual path, instead of action name.

 settings: {
        routes: [
            {
                path: "/api",
                aliases: { 
                    "hello" : "greeter.hello",
                    "users" :  "users.list"
                }             
            }
        ]

http://localhost:3000/api/hello
http://localhost:3000/api/users

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP',
    serializer: "JSON" // not necessary to set, because it is the default
});

// /GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    //override ApiGateWayService properties
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "hello": "greeter.sayHello",
                "hai": "greeter.sayHai",
                "greet": "greeter.sayGreet"
            }

        }, {
            path: '/admin'

        }]
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        },
        sayHai() {
            return 'Hai!';
        },
        sayGreet() {
            return 'Greet!';
        }
    }

})



async function main() {
    await broker.start();
}
main();
.....................................................................................			HTTP Verbs Mapping - GET,POST,PUT,DELETE,PATCH
....................................................................................

aliases: {
   "GET users": "user.list",  //GET list is default method
   "GET users/:id": "user.get", //users/1 users/2 users/3
   "POST users": "user.create",
   "PUT users/:id": "user.update",
   "DELETE users/:id": "user.remove"
}

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')

const broker = new ServiceBroker();

//CURD service : 

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create(ctx) {
            console.log(ctx.params)
            return 'Product Created'
        },
        //update
        update(ctx) {
            return 'Product updated'
        },
        //delete
        remove(ctx) {
            return 'Product removed'
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "GET products": "products.list",  //GET list is default method
                "GET products/:id": "products.get", //users/1 users/2 users/3
                "POST products": "products.create",
                "PUT products/:id": "products.update",
                "DELETE products/:id": "products.remove"
            }
        }]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
.....................................................................................
.....................................................................................
SHORT Cut 


Without short cut
  aliases: {
                "GET users": "user.list",  //GET list is default method
                "GET users/:id": "user.get", //users/1 users/2 users/3
                "POST users": "user.create",
                "PUT users/:id": "user.update",
                "DELETE users/:id": "user.remove"
            }
With Short cut

it will map actions automatically but there is rule , method names should be like below
 aliases: { 
   "REST users" : "users"
 }

method names:
 list
 get
 create
 update
 remove


const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')

const broker = new ServiceBroker();

//CURD service : 

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create(ctx) {
            console.log(ctx.params)
            return 'Product Created'
        },
        //update
        update(ctx) {
            return 'Product updated'
        },
        //delete
        remove(ctx) {
            return 'Product removed'
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                // "GET products": "products.list",  //GET list is default method
                // "GET products/:id": "products.get", //users/1 users/2 users/3
                // "POST products": "products.create",
                // "PUT products/:id": "products.update",
                // "DELETE products/:id": "products.remove"
                "REST products" : "products"
            }
        }]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
Extra methods:



broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                aliases: {
                    "REST users": "users",
                    "GET myapi"(req, res) {
                        // res.end("Hello This is my api")
                        res.end(JSON.stringify(USERS));
                    }
                }
            }
        ]
    }
})

async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
..................................................................................
				Payload : input 
				body,path parameter,querystrings
...................................................................................
const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker()

broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "GET profile/city": "profile.findByCity",
                "REST profile": "profile",
            },
            whitelist: [
                "profile.list", "profile.update", "profile.findByCity", "profile.create", "profile.get"
            ]
        }, {
            path: '/admin'
        }]
    }
})

//payload 
const payload = [
    { id: 1, name: 'Subramanian', status: true },
    { id: 2, name: 'Murugan', status: false },
    { id: 1, name: 'Geetha', status: true }
]

//back end service 
broker.createService({
    name: 'profile',
    actions: {
        list: {
            handler(ctx) {
                return payload
            }
        },
        findByCity: {
            handler(ctx) {
                console.log('query params', ctx.params)
                return 'Query params'
            }
        },
        get: {
            handler(ctx) {
                const params = ctx.params
                console.log('parms', params.id)
                return 'Get By id'
            }
        },
        create: {
            handler(ctx) {
                const inputpayload = ctx.params
                console.log(inputpayload)
                return 'save'
            }
        },
        remove: {
            handler(ctx) {
                return 'remove'
            }
        },
        update: {
            handler(ctx) {
                return 'update'
            }
        }
    }
})

async function main() {
    await broker.start();
}
main();
.....................................................................................	
			   Auto alises
.....................................................................................
const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");

const broker = new ServiceBroker();

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            rest: "GET /",
            handler(ctx) {
                return 'products';
            }
        },
        //GET product by id
        get: {
            rest: "GET /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'products by id'
            }
        },
        //save
        create: {
            rest: "POST /",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product Created'
            }
        },
        //update
        update: {
            rest: "PUT /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        },
        //delete
        remove: {
            rest: "DELETE /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
            },
            autoAliases: true
        }]
    }
})

async function main() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
main()
....................................................................................
			   Microservice Pattern : Data Management	
			       Database Per Service
..............................................................................................

According to Microservice pattern called "Database Per Service".

Databases supported by Moleculer:
1.Mongodb
2.mssql
3.couch
4.macrometa
5.rethink
etc....

Moleculer database Modules provides abstraction on any database layer.
Molecluer database modules provide like hibernate abstraction.


NeDb:
 In memormy and default database for Moleculer

Features:

-Default CURD operations
-Caching enabled
-pagination support
-Pluggable adapter - when even ever you want you can change database
-many adpaters supported
  -mongodb,postresql,sqllight,mysql,mssql.
-filtering supports
-encode and decode
-entity life cycle events

 npm install moleculer-db --save

According to Microservice pattern called "Database Per Service".
....................................................................................
Fakerator lib:
..............
  It is one of the most popular lib for generating mock datas for testing and prototyping..

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const DbService = require('moleculer-db')
const Fakerator = require('fakerator');

//Fakerator object we need to create
const fakerator = new Fakerator();

const broker = new ServiceBroker({
    transporter: 'TCP'
});

//service : expose api which talks to database
//in Mememory Database:NeDB.

broker.createService({
    name: 'users',
    mixins: [DbService],
    adapter: new DbService.MemoryAdapter(),
    //column mapping
    settings: {
        fields: ["_id", "firstName", "lastName", "email", "status"],
        pageSize:200
    },
    actions: {

    },
    //life cycle method
    afterConnected() {
        //seeding the database with default data
        this.logger.info('connection started')
    },
    methods: {
        async seedDB() {
            this.logger.info('Seeding User Database starts');
            //generate fake users
            const fakeUsers = fakerator.times(fakerator.entity.user, 200);
            //insert into db
            const insertedUsers = await this.adapter.insertMany(fakeUsers);
            this.logger.info(`Created ${insertedUsers.length}`)
        }
    },
    //service life cycle
    async started() {
        if ((await this.adapter.count()) === 0) {
            await this.seedDB();
        } else {
            this.logger.info(`DB contains ${await this.adapter.count()} users`)
        }
    }
})


broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                aliases: {
                },
                autoAliases: true
            }
        ]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
.....................................................................................
			   Third Party databases-Mongodb

Adapter:
->moleculer-db - core
->moleculer-db-adpater-mongo

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const DbService = require('moleculer-db')
const MongoDbAdapter = require('moleculer-db-adapter-mongo')
const Fakerator = require('fakerator');

//Fakerator object we need to create
const fakerator = new Fakerator();

const broker = new ServiceBroker({
    transporter: 'TCP'
});

//service : expose api which talks to database
//in Mememory Database:NeDB.

broker.createService({
    name: 'users',
    mixins: [DbService],
    adapter: new DbService.MemoryAdapter(),
    //adapter: new MongoDbAdapter("mongodb://localhost:27017"),
    collection:'users',
    //column mapping
    settings: {
        fields: ["_id", "firstName", "lastName", "email", "status"],
        pageSize:200
    },
    actions: {

    },
    //life cycle method
    afterConnected() {
        //seeding the database with default data
        this.logger.info('connection started')
    },
    methods: {
        async seedDB() {
            this.logger.info('Seeding User Database starts');
            //generate fake users
            const fakeUsers = fakerator.times(fakerator.entity.user, 200);
            //insert into db
            const insertedUsers = await this.adapter.insertMany(fakeUsers);
            this.logger.info(`Created ${insertedUsers.length}`)
        }
    },
    //service life cycle
    async started() {
        if ((await this.adapter.count()) === 0) {
            await this.seedDB();
        } else {
            this.logger.info(`DB contains ${await this.adapter.count()} users`)
        }
    }
})


broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                aliases: {
                },
                autoAliases: true
            }
        ]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
.....................................................................................
                Sequelizer - ORM framework for Node.js based apps

Moleculer uses sequlierzer (https://sequelize.org/)



Steps:
1.start database
PostgreSQL:
 Server:
  docker run --name postgres -p 5432:5432 -e POSTGRES_PASSWORD=postgres -d postgres
CLI:
docker run -it --rm --link postgres:postgres postgres psql -h postgres -U postgres


2.npm install moleculer-db-adapter-sequelize sequelize --save
database driver
3.npm install pg pg-hstore --save


const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')
const DbService = require('moleculer-db')
const SqlAdapter = require("moleculer-db-adapter-sequelize");
const Fakerator = require('fakerator');
const Sequelize = require("sequelize");

//Fakerator object we need to create
const fakerator = new Fakerator();

const broker = new ServiceBroker({
    transporter: "TCP"
})

//api server : http server
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    settings: {
        routes: [
            {
                path: '/api',
                aliases: {
                },
                autoAliases: true
            }
        ]
    }
})

//if you want to work with database we need to inherit db adapters

broker.createService({
    name: 'posts',
    //db service
    mixins: [DbService],
    //adapter configurations says that what type of database you are connecting-postr
    adapter: new SqlAdapter("postgres://postgres:postgres@localhost/postgres"),
    model: {
        name: "post",
        define: {
            title: Sequelize.STRING,
            content: Sequelize.TEXT,
            votes: Sequelize.INTEGER,
            author: Sequelize.STRING,
            status: Sequelize.BOOLEAN
        },
        options: {
            // Options from https://sequelize.org/docs/v6/moved/models-definition/
        }
    }  
})

async function main() {
    await broker.start()
}
main()










	